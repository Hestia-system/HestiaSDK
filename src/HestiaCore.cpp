#include <Arduino.h>
#include "HestiaCore.h"
#include "HestiaProvisioning.h"
#include "HestiaTempo.h"
using Tempo::literals::operator"" _id;

// =====================================================================================
// Internal storage for bridge configuration (injected externally)
// =====================================================================================
namespace {
    const BridgeConfig* g_bridgeTable = nullptr;
    size_t g_bridgeCount = 0;
}

namespace HestiaCore {

    static bool timerFlushSet = false;


    /*****************************************************************************************
     *  Function : loadBridgeConfig
     *  ---------------------------------
     *  Registers an externally provided BridgeConfig table for later instantiation.
     *
     *  Notes:
     *    â€¢ This call only stores pointers; it does not perform any instantiation.
     *      RegisterEntitiesIotBridge() still handles the creation of HAIoTBridge objects.
     *
     *    â€¢ This enables dependency injection as required by Architecture S-2.
     *      The SDK remains device-agnostic: entity lists can now be supplied by firmware
     *      or dynamically generated by external tools (e.g., Hestia Add-on).
     *
     *    â€¢ The table may reside in PROGMEM. Only the pointer and count are retained.
     */
    void loadBridgeConfig(const BridgeConfig* table, size_t count) {
        g_bridgeTable = table;
        g_bridgeCount = count;

        Serial.print(F("[HestiaCore] loadBridgeConfig: table="));
        Serial.print((uintptr_t)table, HEX);
        Serial.print(F(" rows = "));
        Serial.println(count);
        Serial.println(F("=== BridgeConfig table loaded ===\n"));
    }


    // =====================================================================================
    //  Active Bridge Registry
    // =====================================================================================
    std::vector<HAIoTBridge*> BridgeRegistry;

    // =====================================================================================
    //  Communication State and Watchdog Tracking
    // =====================================================================================

    bool wdtInitialized    = false;         // Watchdog initialization state
    bool mqttOK            = false;         // MQTT connection state

    // -------------------------------------------------------------------------
    //  HA-layer state
    // -------------------------------------------------------------------------
    static bool     ha_online           = false;  // HA_online bridge current value
    static bool     ha_onlineMem        = false;  // HA_online bridge old value
    static bool     ha_init_done        = false;  // Set via setHAInitDone() from main




    // =====================================================================================
    //  logSummary() â€” Diagnostic summary of all registered entities
    // =====================================================================================
    void logSummary() {
        Serial.println(F("\n=== [HestiaCore::logSummary | BridgeRegistry] Entity Summary ==="));
        for (auto* b : BridgeRegistry) {
            Serial.printf(" %-30s | Type: %-11s | TopicTo: %-25s\n",
                          b->name().c_str(),
                          (b->type() == TypeHA::HA_CONTROL   ? "CONTROL" :
                           b->type() == TypeHA::HA_INDICATOR ? "INDICATOR" :
                           b->type() == TypeHA::HA_BUTTON    ? "BUTTON" :
                           b->type() == TypeHA::HA_ENTITIES  ? "ENTITIES" : "?"),
                          b->topicTo().c_str());
        }
        Serial.println(F("=== [BridgeRegistry] End of Summary ===\n"));
    }


    // =====================================================================================
    //  InitValueNVS() â€” Restore values from NVS through each bridge object
    // =====================================================================================
    /**
     * @brief Restore all HAIoTBridge-controlled values from NVS.
     *
     * Behavior:
     *   â€¢ Iterates through the registry and invokes each entity's init() method.
     *   â€¢ Each entity decides whether to restore from NVS or use default metadata.
     */
    bool InitValueNVS() {
        Serial.println(F("\n=== [HestiaCore::InitValueNVS] Restoring local NVS values ==="));

        for (auto* bridge : BridgeRegistry) {
            if (!bridge) continue;
            bridge->init();
        }

        Serial.println(F("=== [HestiaCore::InitValueNVS] Local initialization complete ===\n"));
        return true;
    }

    // =====================================================================================
    //  publishValuesToHA() â€” Publish values to HA through each bridge object
    // =====================================================================================
    /**
     * @brief Publish all HAIoTBridge-controlled values to HA.
     *
     * Behavior:
     *   â€¢ Iterates through the registry and invokes each entity's init() method.
     *   â€¢ Publish MQTT to HA for each entity.
     */
    bool publishValuesToHA() {
        Serial.println(F("\n=== [HestiaCore::publishValuesToHA] Publishing values to HA ==="));

        for (auto* bridge : BridgeRegistry) {
            if (!bridge) continue;
            bridge->publishValueToHA();
        }

        Serial.println(F("=== [HestiaCore::publishValuesToHA] Publishing complete ===\n"));
        return true;
    }


 



    /*****************************************************************************************
     *  RegisterEntitiesIotBridge()
     *  ---------------------------------------------------------------
     *  Instantiate all HAIoTBridge objects from the injected BridgeConfig table.
     *
     *  Architecture S-2 Notes:
     *    â€¢ The internal static bridge_config[] array is no longer referenced.
     *    â€¢ Instead, the firmware (or external tools) injects a BridgeConfig table
     *      via loadBridgeConfig().
     *
     *  Benefits:
     *    â€¢ Device-agnostic SDK
     *    â€¢ Supports very large tables stored in PROGMEM
     *    â€¢ Allows dynamic configuration generation
     *
     *  Constraints:
     *    â€¢ Behavior is identical to R1/R0 unless loadBridgeConfig() is used.
     *    â€¢ Future architectures will rely on this injection mechanism by default.
     *****************************************************************************************/
    void RegisterEntitiesIotBridge() {
        Serial.println(F("\n=== [HestiaCore | BridgeRegistry] Creating entities ==="));

        // Safety: ensure that loadBridgeConfig() has been called
        if (!g_bridgeTable || g_bridgeCount == 0) {
            Serial.println(F("[HestiaCore] FATAL: No BridgeConfig table loaded."));
            return;
        }

        // Instantiate all configured entities
        for (size_t i = 0; i < g_bridgeCount; ++i) {
            const BridgeConfig& cfg = g_bridgeTable[i];
            HAIoTBridge* bridge = new HAIoTBridge(cfg);
            BridgeRegistry.push_back(bridge);
        }

        HestiaCore::logSummary();

        Serial.println(F("=== [BridgeRegistry] Initialization completed ==="));
    }

    // =====================================================================================
    //  initCore() â€” Complete communication state machine
    // -------------------------------------------------------------------------------------
    static bool _coreInitialized = false;

    bool initCore(
        const char* deviceParamsJson,
        const BridgeConfig* bridgeConfig,
        size_t bridgeCount,
        const char* discoveryJson
    )
    {
        // ---------------------------------------------------------------------
        // Guard: prevent double initialization
        // ---------------------------------------------------------------------
        if (_coreInitialized) {
            Serial.println(F("[HestiaCore] WARNING: initCore() called more than once."));
            return false;
        }
        _coreInitialized = true;

        Serial.println(F("=== [HestiaCore] Core initialization start ==="));

        // 0) Minimal hardware initialization
        HardwareInit::InitHardwareMinimal();
        Serial.println(F("[HestiaCore] Minimal hardware initialized"));

        // 1) Load device parameters (R2 JSON â†’ HestiaParam objects)
        if (!HestiaConfig::loadDeviceParams(deviceParamsJson)) {
            Serial.println(F("[HestiaCore] ERROR: DeviceParams loading failed"));
            return false;
        }
        Serial.println(F("[HestiaCore] Device parameters loaded"));

        // 2) Validate configuration and provisioning decision
        if (!HestiaConfig::validateR2() || HestiaConfig::ForceProvisioning()) {
            Serial.println(F("[HestiaCore] Provisioning mode triggered"));
            Provisioning::StartProvisioning(deviceParamsJson);
            // NEVER RETURNS
        }
        Serial.println(F("[HestiaCore] Configuration validated"));

        // 3) Initialize watchdog (after provisioning only)
        if (HestiaConfig::getParamObj("watchdog_ms")) {
            HardwareInit::InitHardwareWatchdog(HestiaConfig::getParamObj("watchdog_ms")->readInt());
            Serial.println(F("[HestiaCore] Watchdog initialized"));
        } else {
            Serial.println(F("[HestiaCore] Watchdog disabled (no parameter)"));
        }

        // 4) Inject bridge configuration and discovery JSON
        loadBridgeConfig(bridgeConfig, bridgeCount);
        HestiaNet::loadDiscoveryJson(discoveryJson);

        Serial.printf(
            "[HestiaCore] Bridge configuration loaded (%u entries)\n",
            (unsigned)bridgeCount
        );

        // 5) Create and register all HAIoTBridge entities
        RegisterEntitiesIotBridge();
        Serial.println(F("[HestiaCore] HAIoTBridge entities registered"));

        // 6) Load NVS values for CONTROL-type bridges
        InitValueNVS();
        Serial.println(F("[HestiaCore] NVS values restored"));

        // 7) Silent mode for diagnostics-only entities
        if (HestiaCore::get("IotBridge_ip")) {
            HestiaCore::get("IotBridge_ip")->setLogWrites(false);
            Serial.println(F("[HestiaCore] Silent mode for diagnostics-only entities IotBridge_ip "));
        }

        // 8) Initial system heartbeat
        if (HestiaCore::get("IotBridge_iotHeartbeat")) {
            HestiaCore::get("IotBridge_iotHeartbeat")->write("TICK");
            HestiaCore::get("IotBridge_iotHeartbeat")->setLogWrites(false); // Silent mode
            Serial.println(F("[HestiaCore] Initial heartbeat sent"));
        }

        Serial.println(F("=== [HestiaCore] Core initialization complete ==="));
        return true;
    }



    // =====================================================================================
    //  CoreComm() â€” Complete communication state machine
    // -------------------------------------------------------------------------------------
    //  Implements the full non-blocking connectivity pipeline:
    //
    //    1) Wi-Fi Guard
    //         â€¢ Try reconnecting without blocking
    //         â€¢ Detect new Wi-Fi epochs
    //
    //    2) Wi-Fi Milestones
    //         â€¢ Print Wi-Fi diagnostics
    //         â€¢ (Optional) mDNS registration
    //
    //    3) MQTT Guard
    //         â€¢ Auto-connect to broker
    //         â€¢ Detect new MQTT epochs
    //
    //    4) MQTT Discovery
    //         â€¢ Publish Home Assistant discovery payloads once per session
    //
    //    5) MQTT Subscription
    //         â€¢ Subscribe to all HA_CONTROL and HA_BUTTON input topics
    //
    //    6) Retained-message Flush
    //         â€¢ Avoid old retained messages interfering with the device
    //         â€¢ Window duration: mqtt_flush_window (ms)
    //
    //    7) Online/Loss Handling
    //         â€¢ Reset communication state
    //         â€¢ Feed watchdog continuously
    //
    //  CoreComm() must be called from loop() at high frequency.
    // =====================================================================================
    enum class CommState {
        WIFI_NOT_READY,
        WIFI_READY,
        MQTT_READY,
        HA_ONLINE_WAIT,
        HA_ONLINE_CONFIRM,
        DISCOVERY,
        START_FLUSH,
        SUBSCRIPTION,
        START_TIMER_FLUSH,
        CHECK_TIMER_FLUSH,
        END_FLUSH,
        HA_NEWSEQCOM,
        HA_INIT_WAIT,
        HA_INIT_DONE,
        SYSTEM_RUNNING
    };
    CommState coreState = CommState::WIFI_NOT_READY;
    bool FlushState   = false;
    bool ha_ok       = false;

    void CoreComm() { 

        // Cache du bridge HA_online
        static HAIoTBridge* haOnlineBridge = nullptr;
        static HAIoTBridge* haHeartbeatBridge = nullptr;
        // Cache heartbeat timeout value
        static uint32_t haHbTimeout =
                 HestiaConfig::getParamObj("ha_heartbeat_timeout_ms")->readInt();
        static const char* HA_HB_TIMER = "HA_HB_TIMER";

        // -------------------------------------------------------------------------
        // 1) Wi-Fi Guard: non-blocking reconnection attempts
        // -------------------------------------------------------------------------
        bool wifiOK = HestiaNet::tryWiFiConnectNonBlocking();

        if (wifiOK && coreState == CommState::WIFI_NOT_READY) {
            Serial.printf("[HestiaCore::CoreComm] ðŸŒ New Wi-Fi session ");
            Serial.flush();
            coreState = CommState::WIFI_READY;
        }
        else if (!wifiOK) {
            coreState = CommState::WIFI_NOT_READY;
        }
    
        // -------------------------------------------------------------------------
        // 2) MQTT Guard: non-blocking reconnection attempts
        // -------------------------------------------------------------------------
        if (coreState >= CommState::WIFI_READY) {
            // Wi-Fi is ready or all subsequent states, check MQTT
            bool mqttOK = HestiaNet::tryMQTTConnectNonBlocking();

            if (mqttOK && coreState == CommState::WIFI_READY) {
            Serial.println("[HestiaCore::CoreComm] ðŸŒ New MQTT session ");
            Serial.flush();
            coreState = CommState::MQTT_READY;
            }
            if (!mqttOK) {
                coreState = CommState::WIFI_READY;
            }
        }

        // -------------------------------------------------------------------------
        // Load HA_online bridge once
        // -------------------------------------------------------------------------
        if (!haOnlineBridge) {
            haOnlineBridge = HestiaCore::get("IotBridge_HA_online");
        }
        if (!haHeartbeatBridge) {
            haHeartbeatBridge = HestiaCore::get("IotBridge_HA_heartbeat");
        }   

        switch (coreState) {

            // =====================  MQTT LAYER  =====================
            case CommState::MQTT_READY:
                Serial.println(F("[CoreComm] MQTT ready â†’ Waiting for HA_online"));
                coreState = CommState::HA_ONLINE_WAIT;
                break;
            
                // =====================  HA SYNCHRO  =====================
            case CommState::HA_ONLINE_WAIT:
            {
                HestiaNet::startMessageReceived(); // Start MQTT message received
                String topic = "";
                if (haOnlineBridge)
                    topic = haOnlineBridge->topicFrom();
                if (topic.length() > 0){
                    client.subscribe(topic.c_str());
                } else {
                    Serial.println(F("[CoreComm] WARNING: HA_online bridge not found or has no topic."));
                }
                ha_ok = haOnlineBridge && haOnlineBridge->readBool();
                if (ha_ok) {
                    Serial.println(F("[CoreComm] HA_online detected â†’ proceeding"));
                    coreState  = CommState::HA_ONLINE_CONFIRM;
                } else {
                    coreState = CommState::HA_ONLINE_WAIT;
                }
                break;
            }
            case CommState::HA_ONLINE_CONFIRM:
                Serial.println(F("[CoreComm] HA confirmed online â†’ Starting HA pipeline"));
                Serial.flush();
                coreState = CommState::DISCOVERY;
                break;
            
            // =====================  DISCOVERY  =====================
            case CommState::DISCOVERY:
                Serial.println("=== [HestiaCore::CoreComm | Discovery] Starting Home Assistant discovery ===");
                Serial.flush();
                HestiaNet::MQTTDiscovery();
                coreState = CommState::START_FLUSH;
                break;

            // ==============  PIPELINE HA : FLUSH + SUBSCRIBE  ==============
            case CommState::START_FLUSH:
                // 1) Activer la logique de flush cÃ´tÃ© HAIoTBridge
                Serial.println(F("=== [HestiaCore::CoreComm | MQTT Flush] Starting retained message flush ==="));
                Serial.flush();
                FlushState   = true;
                HestiaNet::startMessageReceived();   // Start MQTT message received
                coreState = CommState::SUBSCRIPTION;
                break;

            case CommState::SUBSCRIPTION:
                // 2) Topics subscription
                Serial.println(F("=== [HestiaCore::CoreComm | MQTT Subscribe] Subscribing topics ==="));
                Serial.flush();
                for (auto &bridge : BridgeRegistry) {
                    String topic = bridge->topicFrom();
                    if (topic.length() > 0) {
                        client.subscribe(topic.c_str());
                    }
                }
                Serial.println(F("=== [HestiaCore::CoreComm | MQTT Subscribe] Completed ===\n"));
                Serial.flush();
                coreState = CommState::START_TIMER_FLUSH;
                break;

            case CommState::START_TIMER_FLUSH:
                // 3) Starting timer flush
                Serial.println(F("[HestiaCore::CoreComm | MQTT] ðŸ”­ Starting timer flush..."));
                Serial.flush();
                Tempo::oneShot("MQTT_FLUSH_TIMER"_id).start(
                    HestiaConfig::getParamObj("mqtt_flush_window")->readInt()
                );

                coreState = CommState::CHECK_TIMER_FLUSH;
                break;

            case CommState::CHECK_TIMER_FLUSH:
                // 4) Checking retained message flush completion
                if (Tempo::oneShot("MQTT_FLUSH_TIMER"_id).done()) {
                    coreState = CommState::END_FLUSH;
                }
                break;

            case CommState::END_FLUSH:
                // Flush terminÃ© : on peut maintenant attendre HA_online
                FlushState   = false;
                Serial.println(F("[HestiaCore::CoreComm | MQTT] ðŸ”­ Retained message flush complete."));
                Serial.flush();
                ha_ok = haOnlineBridge && haOnlineBridge->readBool();
                if (!ha_ok) {
                    Serial.println(F("[HestiaCore::CoreComm | HA] âœ… HA is offline."));
                    coreState = CommState::HA_ONLINE_WAIT;
                }
                else {
                    coreState = CommState::HA_NEWSEQCOM;
                }
                break;


            // =====================  HAInit  =====================
            case CommState::HA_NEWSEQCOM:
                Serial.println(F("[HestiaCore::CoreComm | HAInit ] âœ… New sequence communication started."));
                Serial.flush();
                coreState = CommState::HA_INIT_WAIT;
                break;
        
            case CommState::HA_INIT_WAIT:
                Serial.print(".");
                coreState = CommState::HA_INIT_WAIT;
                break;

            case CommState::HA_INIT_DONE:  
            {       
                Serial.println(F("\n=== [HestiaCore::CoreComm | HAInit ] âœ…  HAInit complete. System running. ===\n"));

                // start HA heartbeat timeout
                Tempo::oneShot("HA_HB_TIMER"_id).start(haHbTimeout);
                
                coreState = CommState::SYSTEM_RUNNING;
                break;
            }
            case CommState::SYSTEM_RUNNING:
            {
                ha_ok = haOnlineBridge && haOnlineBridge->readBool();

                // 1) Si HA_online = false â†’ retour HA_ONLINE_WAIT
                if (!ha_ok) {
                        Serial.println(F("[CoreComm] HA offline detected â†’ entering HA_ONLINE_WAIT"));
                        coreState = CommState::HA_ONLINE_WAIT;
                }

                // 2) Heartbeat HA â†’ ESP

                bool hbChanged = haHeartbeatBridge && haHeartbeatBridge->onChange();
                //String hb = haHeartbeatBridge->read();
                //Serial.println(hb);
                if (hbChanged) {

                     Tempo::oneShot("HA_HB_TIMER"_id).start(haHbTimeout); // reset watchdog
                    //Serial.println(F("[CoreComm] HA heartbeat received â†’ watchdog reset"));
                }
                else if (Tempo::oneShot("HA_HB_TIMER"_id).done()) {
                    Serial.println(F("[CoreComm] WARNING: HA heartbeat timeout"));
                    coreState = CommState::HA_ONLINE_WAIT;
                    break;
                }
            }  

                default:
                break;
        }

        // MQTT loop + watchdog, tant que MQTT reste connectÃ©
        if (coreState >= CommState::MQTT_READY) {
            client.loop();
        }

        HardwareInit::watchdogKick();
    }



    // =====================================================================================
    //  Communication State Helpers
    // =====================================================================================
    bool commOK() {
        if (coreState >= CommState::HA_ONLINE_CONFIRM) {
            return true;
        }
        return false;
    }

    /**
     * @brief Detect the first online transition after Wi-Fi + MQTT stabilizes.
     *
     * Returns true once per full communication session (epoch).
     */
    bool newSeqComm() {
        if (coreState == CommState::HA_NEWSEQCOM) {
            coreState = CommState::HA_INIT_WAIT;
            return true;
        }
        return false;
    }

    // =====================================================================================
    //  HAInitDone setter â€” called from main after HAInit()
    // =====================================================================================
    void setHAInitDone() {
        if (coreState == CommState::HA_INIT_WAIT) {
            coreState = CommState::HA_INIT_DONE;
            return;
        }
        return;
    }

    /**
     * @brief Check whether the entire communication pipeline is fully operational.
     *
     * Returns true once per full communication session (epoch) and INIT_HA.
     */

    bool InitHAOK(){
        if (coreState == CommState::SYSTEM_RUNNING) {
            return true;
        }
        return false;
    }



    // =====================================================================================
    //  Entity Lookup Helpers
    // =====================================================================================
    HAIoTBridge* get(const String& name) {
        for (auto* b : BridgeRegistry)
            if (b->name() == name)
                return b;
        return nullptr;
    }

    void initAll() {
        for (auto* b : BridgeRegistry)
            b->init();
    }

    void resetAll() {
        for (auto* b : BridgeRegistry)
            b->reset();
    }


    // =====================================================================================
    //  onMessageReceived â€” MQTT dispatching to entities
    // =====================================================================================
    void onMessageReceived(String &topic, String &payload) {

        for (auto &bridge : BridgeRegistry) {
            if (bridge->readMQTT(topic, payload, FlushState)) {
                return; // Message handled, stop scanning
            }
        }
    }



    // =====================================================================================
    //  publishToMQTT â€” Centralized publication with optional logging
    // =====================================================================================
    void publishToMQTT(const String &topic, const String &payload, bool logIt) {
        if (commOK()) {
            MQTTrefreshWithDelay(1);
            client.publish(topic.c_str(), payload.c_str());

            if (logIt) {
                logBook("HestiaCore | Publish topic: " + topic +
                        " | payload: " + payload);
            }
        }
    }


    // =====================================================================================
    //  logBook â€” Unified logger (Serial + HA logging)
    // =====================================================================================
    void logBook(const String& msg) {
        String formatted = "[Log] " + msg;

        // Local console
        Serial.println(formatted);

        // MQTT log stream (only if connected)
        client.publish(HestiaConfig::getParam("ha_log_topic").c_str(), formatted);
    }


    // =====================================================================================
    //  HAInit â€” Home Assistant initialization
    // =====================================================================================
    void HAInit() {

        Serial.println();
        Serial.println();

        HestiaCore::logBook("=== [HAInit] Home Assistant initialization ===");

        // Restore NVS values for CONTROL-type entities
        HestiaCore::publishValuesToHA();
        Serial.println("publishValuesToHA finished");


        delay(100); // ensure HA-side automations detect the new online state


        // ---------------------------------------------------------------------
        // Log configuration and firmware information
        // ---------------------------------------------------------------------
        String model    = HestiaConfig::getParam("model");
        String version  = HestiaConfig::getParam("version_prog");
        String devID    = HestiaConfig::getParam("device_id");

        HestiaCore::logBook("Model      : " + model + " " + version);
        HestiaCore::logBook("Device ID  : " + devID);
        HestiaCore::logBook("Build      : " + String(__DATE__) + " " + String(__TIME__));


        // ---------------------------------------------------------------------
        // Network State Logging
        // ---------------------------------------------------------------------
        String ssid   = WiFi.SSID();
        int    rssi   = WiFi.RSSI();
        String ipStr  = WiFi.localIP().toString();
        String bssid  = WiFi.BSSIDstr();

        HestiaCore::logBook("[*] Network information for SSID : " + ssid);
        HestiaCore::logBook("[+] RSSI       : " + String(rssi) + " dBm");
        HestiaCore::logBook("[+] IP address : " + ipStr);
        HestiaCore::logBook("[+] MAC (BSSID): " + bssid);


        // ---------------------------------------------------------------------
        // HA internal values
        // ---------------------------------------------------------------------
        HestiaCore::get("IotBridge_SW_version")->write(devID + " " + version);
        HestiaCore::get("IotBridge_ip")->write(ssid + " @ " + String(rssi) + " dB");



        // ---------------------------------------------------------------------
        // User section : for real sensor initialization (optional)
        // ---------------------------------------------------------------------
        Serial.println(F("=== [HAInit] user initialization ==="));

        // Example macros:
        // auto* ph = HA("sensor_ph");
        // if (ph) ph->write(lireCapteurPH());
        //
        // auto* temp = HA("sensor_temp");
        // if (temp) temp->write(lireTempEau());

        Serial.println(F("=== [HAInit] finished ==="));
    }

} // namespace HestiaCore
// =====================================================================================